<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2-sat问题详解</title>
    <url>/2024/05/31/2-sat%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>解决俩俩出现矛盾时的分组问题</p>
<span id="more"></span>
<h1 id="2-sat基础"><a href="#2-sat基础" class="headerlink" title="2-sat基础"></a>2-sat基础</h1><h2 id="2-sat简介"><a href="#2-sat简介" class="headerlink" title="2-sat简介"></a>2-sat简介</h2><p>2-SAT，简单的说就是给出 $n$ 个集合，每个集合有两个元素，已知若干个 $&lt;a,b&gt;$，表示 $a$ 与 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。</p>
<p>比如邀请人来吃喜酒，夫妻二人必须去一个，然而某些夫妻之间有矛盾，那么我们要确定能否避免来人之间有矛盾，有时需要方案。这是一类生活中常见的问题。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>参考网上公认的大牛的文章，提供两种不同的思考方向</p>
<ol>
<li><p><a href="https://wenku.baidu.com/view/afd6c436a32d7375a41780f2.html?_wkts_=1680438067572">由对称性解2-SAT问题 </a>  </p>
</li>
<li><p><a href="https://wenku.baidu.com/view/0f96c3daa58da0116c1749bc.html?_wkts_=1680438097877">2-SAT 解法浅析</a></p>
</li>
</ol>
<h2 id="通用解题思路"><a href="#通用解题思路" class="headerlink" title="通用解题思路"></a>通用解题思路</h2><p>假设有 $a1,a2$ ,和 $b1,b2$ 两对元素,  $&lt;a1,b1&gt;$ 表示 $a1,b1$ 之间有矛盾，由于$a$ 和 $b$ 必须选出一个，我们用两条有向边 $(a1,b2)$  $(b1,a2)$ 表示下面两个方案</p>
<ol>
<li>选择 $a1$ ,由于 $&lt;a1,b1&gt;$ ，那么必须选择 $b2$ </li>
<li>选择 $b1$ ,由于 $&lt;a1,b1&gt;$ ，必须选择 $a2$</li>
</ol>
<p>类似的构造完所有边之后，我们跑一遍  $Tarjan$  判断是否有一个集合中的两个元素在同一个 $SCC$ 中，若有则输出不可能，否则输出方案。构造方案只需要把几个不矛盾的 $SCC$ 拼起来就好了。</p>
<p>输出方案时可以通过变量在图中的拓扑序确定该变量的取值。如果变量 $x$ 的拓扑序在 $\neg x$ 之后，那么取 $x$ 值为真。应用到 $Tarjan$ 算法的缩点，即 $x$ 所在 $SCC$ 编号在 $\neg x$ 之前时，取 $x$ 为真，否则取 $x$ 为假。因为 $Tarjan$ 算法求强连通分量时使用了栈，所以 $Tarjan$ 求得的 $SCC$ 编号相当于反拓扑序。</p>
<p>时间复杂度为 $O(n+m)$ </p>
<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><h3 id="【模板】2-SAT-问题"><a href="#【模板】2-SAT-问题" class="headerlink" title="【模板】2-SAT 问题 "></a><a href="https://www.luogu.com.cn/problem/P4782">【模板】2-SAT 问题 </a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 $n$ 个布尔变量 $x_{^1} \sim x_{^n}$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 <code>true</code> &#x2F; <code>false</code> 或 $x_j$ 为 <code>true</code> &#x2F; <code>false</code>」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。</p>
<p>2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 $n$ 和 $m$，意义如题面所述。</p>
<p>接下来 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\in {0,1}$)</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如无解，输出 <code>IMPOSSIBLE</code>；否则输出 <code>POSSIBLE</code>。</p>
<p>下一行 $n$ 个整数 $x_1\sim x_n$（$x_i\in{0,1}$），表示构造出的解。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤10^6$  </p>
<h4 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h4><p>每一个条件都是形如  $a\lor b $ 的约束，各种约束条件对应的逻辑命题如下：</p>
<table>
<thead>
<tr>
<th>$a \lor b$</th>
<th>$\neg a \to b$            $ \neg b \to a$</th>
</tr>
</thead>
<tbody><tr>
<td>$\neg a \lor b$</td>
<td>$a \to b$             $\neg b \to \neg a$</td>
</tr>
<tr>
<td>$a\lor b$</td>
<td>$\neg a \to \neg b$        $ b \to a$</td>
</tr>
<tr>
<td>$\neg a\lor \neg b$</td>
<td>$a \to \neg b$           $b \to \neg a$</td>
</tr>
</tbody></table>
<p>建图之后判断是否存在$x$和$\neg x$在同一强连通分量，若不存在则有解，否则无解。</p>
<p>如果 $x$的拓扑序 在$\neg x$ 之后，选择 $x$ ，否则选择$\neg x$ ，实际处理的时候，$tarjan$ 求得的是反拓扑序，即 $x$ 和$\neg x$ 谁序号越小选谁。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e6</span> + <span class="number">7</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> d[N], pre[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[idx] = b;</span><br><span class="line">  ne[idx] = h[a];</span><br><span class="line">  h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], times = <span class="number">0</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> scc[N], sid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++times;</span><br><span class="line">  stk.<span class="built_in">push</span>(u);</span><br><span class="line">  in_stk[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[j]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(j);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[j], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[j], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    ++sid;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = stk.<span class="built_in">top</span>();</span><br><span class="line">      stk.<span class="built_in">pop</span>();</span><br><span class="line">      in_stk[p] = <span class="literal">false</span>;</span><br><span class="line">      scc[p] = sid;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scc[i] == scc[i + n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> x, a, y, b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">add</span>(x + n, y);</span><br><span class="line">      <span class="built_in">add</span>(y + n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">add</span>(x + n, y + n);</span><br><span class="line">      <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">add</span>(x, y);</span><br><span class="line">      <span class="built_in">add</span>(y + n, x + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">add</span>(x, y + n);</span><br><span class="line">      <span class="built_in">add</span>(y, x + n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">solve</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;POSSIBLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      cout &lt;&lt; (scc[i] &lt; scc[i + n]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="卡图难题"><a href="#卡图难题" class="headerlink" title="卡图难题"></a><a href="https://www.acwing.com/problem/content/372/">卡图难题</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 $n$ 个布尔变量 $X_0\sim X_{n-1}$，每个变量的可能取值为$0$或$1$。</p>
<p>给定M个算式，每个算是形如$X_a$ $op$ $X_b &#x3D; c$ ，其中$a$ ,$b$ 是变量编号，$c$ 是数字$0$或 $1$，$op$ 是 $AND$ $OR$ $XOR$三个位运算之一。</p>
<p>求是否存在对每个变量的合法赋值，使所有算式都成立。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数 $n$ 和 $m$。</p>
<p>接下来$M$行，每行包含三个整数 $a,b,c$，以及一个位运算（$AND$,$OR$,$XOR$ 中的一个）。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出结果，如果存在，输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1&lt;&#x3D;N&lt;&#x3D;1000$</p>
<p>$1&lt;&#x3D;M&lt;&#x3D;10^6$ </p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">0 1 1 AND</span><br><span class="line">1 2 1 OR</span><br><span class="line">3 2 0 AND</span><br><span class="line">3 0 0 XOR</span><br></pre></td></tr></table></figure>

<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>



<h4 id="求解思路-1"><a href="#求解思路-1" class="headerlink" title="求解思路"></a>求解思路</h4><p>每个元素都只有两种取值方案，这仍然是一道2-sat</p>
<p>同样按题目要求得出对应的逻辑，按照一下逻辑构图，</p>
<table>
<thead>
<tr>
<th>运算规则</th>
<th>转换逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>$a$ &amp; $b &#x3D;1$</td>
<td>$\neg a \to a$  &nbsp;&nbsp;&nbsp;&nbsp; $\neg b \to b$</td>
</tr>
<tr>
<td>$a$ &amp; $b &#x3D;0$</td>
<td>$a \to \neg b$ &nbsp;&nbsp;&nbsp;&nbsp; $b \to \neg a$</td>
</tr>
<tr>
<td>$a|b&#x3D;1$</td>
<td>$\neg a \to  b$ &nbsp;&nbsp;&nbsp;&nbsp;  $\neg b \to a$</td>
</tr>
<tr>
<td>$a|b&#x3D;0$</td>
<td>$a \to \neg a$  &nbsp;&nbsp;&nbsp;&nbsp;  $b \to \neg b$</td>
</tr>
<tr>
<td>$a \land b&#x3D;1$</td>
<td>$a \to  b$   $b \to a$  &nbsp;&nbsp;&nbsp;&nbsp;  $\neg a \to \neg b$  &nbsp;&nbsp;&nbsp;&nbsp; $\neg b \to \neg a$</td>
</tr>
<tr>
<td>$a \land b&#x3D;0$</td>
<td>$a \to \neg b$ &nbsp;&nbsp;&nbsp;&nbsp;   $b \to \neg a$ &nbsp;&nbsp;&nbsp;&nbsp;    $\neg a \to b$  &nbsp;&nbsp;&nbsp;&nbsp;   $\neg b \to a$</td>
</tr>
</tbody></table>
<p>我们用$x$表示$1$, $x+n$ 表示0 也就是$\neg x$ </p>
<p>建图之后判断是否存在$x$和$\neg x$在同一强连通分量，若不存在则有解，否则无解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tarjan直接套用即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++)</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low[i] == low[i + n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> a, b, c;</span><br><span class="line">  string ch;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a + n, a); <span class="built_in">add</span>(b + n, b);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(a, b + n); <span class="built_in">add</span>(b, a + n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a + n, b); <span class="built_in">add</span>(b + n, a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(a, a + n); <span class="built_in">add</span>(b, b + n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(a, b); <span class="built_in">add</span>(b, a);</span><br><span class="line">        <span class="built_in">add</span>(a + n, b + n); <span class="built_in">add</span>(b + n, a + n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">add</span>(a, b + n); <span class="built_in">add</span>(a + n, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a + n); <span class="built_in">add</span>(b + n, a);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Wedding"><a href="#Wedding" class="headerlink" title="Wedding"></a><a href="https://vjudge.net/problem/Kattis-wedding">Wedding</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>最多30对新人将参加婚宴，他们将坐在长桌的两边。新娘和新郎坐在一端，彼此相对，新娘戴着一个精心制作的头饰，她不会看到和她坐在同一边的人。丈夫和妻子坐在桌子的同一侧被认为是不吉利。此外，还有几对人存在矛盾，有矛盾的人坐在同一侧也被认为是不吉利的。你的工作是安排餐桌上的人，以避免任何不吉利</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组测试用例。</p>
<p>第一行两个整数 $n$ 和 $m$。表示共有 $n$ 对夫妇，$m$ 对矛盾关系。接下来 $m$ 行，每行揭露一个矛盾关系。</p>
<p>如 <code>7h 3w</code> 表示第 7 对夫妇中的丈夫和第 3 对夫妇中的妻子有矛盾。</p>
<p>每对夫妇被编号为 <code>0,1,...,n-1</code>，其中新郎新娘的编号为 0。</p>
<p>当输入一行为 <code>0 0</code> 时，表示输入终止。</p>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组测试用例输出一个结果，每个结果占一行。结果包含同新娘坐在一侧的人员列表。如果有多种方案，随便输出一种即可。</p>
<p>输出结果时，请按照编号从小到大的顺序，输出人员。如果没有方案，则输出 <code>bad luck</code>。</p>
<h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 6</span><br><span class="line">3h 7h</span><br><span class="line">5w 3w</span><br><span class="line">7h 6w</span><br><span class="line">8w 3w</span><br><span class="line">7h 3w</span><br><span class="line">2w 5h</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1h 2h 3w 4h 5h 6h 7h 8h 9h</span><br></pre></td></tr></table></figure>

<h4 id="求解思路-2"><a href="#求解思路-2" class="headerlink" title="求解思路"></a>求解思路</h4><p>1.首先定义i为妻子，i+n为丈夫，夫妻之中妻子的真值为true，丈夫的真值为false（可以尝试换一种定义方式，然后修改代码，检验自己是否完全理解$2-sat$） </p>
<p>2.题目要求输出和新娘在同一侧的人员名单，而新娘的编号是0，也就是说在有解的情况下，0是必选的，0与n是夫妻关系，n必不选，为了必选0，需要加一条由丈夫指向妻子的边，即add(n,0)</p>
<p>3.如果有解，那么选择夫妻之间拓扑序小的坐新娘这侧。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tarjan模板略</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">  <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">  <span class="built_in">memset</span>(in_stk, <span class="number">0</span>, <span class="keyword">sizeof</span> in_stk);</span><br><span class="line">  <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">  <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) stk.<span class="built_in">pop</span>();</span><br><span class="line">  idx = <span class="number">1</span>;</span><br><span class="line">  sid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n + m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> a, c, pa, pc;</span><br><span class="line">    <span class="type">char</span> b, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">      <span class="keyword">if</span> (b == <span class="string">&#x27;h&#x27;</span>) pa = a, a = a + n;</span><br><span class="line">      <span class="keyword">else</span> pa = a + n;</span><br><span class="line">      <span class="keyword">if</span> (d == <span class="string">&#x27;h&#x27;</span>) pc = c, c = c + n;</span><br><span class="line">      <span class="keyword">else</span> pc = c + n;</span><br><span class="line">      <span class="built_in">add</span>(pa, c);</span><br><span class="line">      <span class="built_in">add</span>(pc, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">solve</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scc[i] &lt; scc[i + n]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;w&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;h&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;bad luck&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平面图判定"><a href="#平面图判定" class="headerlink" title="平面图判定"></a><a href="https://www.luogu.com.cn/problem/P3209">平面图判定</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>若能将无向图 $G&#x3D;(V, E)$ 画在平面上使得任意两条无重合顶点的边不相交，则称 $G$ 是平面图。判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图，图中存在一个包含所有顶点的环，即存在哈密顿回路。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件的第一行是一个正整数 $T$，表示数据组数 (每组数据描述一个需要判定的图)。</p>
<p>每组数据的第一行是用空格隔开的两个正整数 $N$ 和 $M$，分别表示对应图的顶点数和边数。</p>
<p>紧接着 $M$ 行，每行两个正整数 $u$ 和 $v$ $\left(1\leq u,v\leq N\right)$，表示对应图的一条边 $\left(u,v\right)$, 输入的数据保证所有边仅出现一次。</p>
<p>每组数据的最后一行是用空格隔开的 $N$ 个正整数，从左到右表示对应图中的一个哈密顿回路：$V_1,V_2,…,V_N$，即对任意 $i\not&#x3D;j$ 有 $V_i\not&#x3D;V_j$ 且对任意 $1\leq i\leq N-1$ 有 $\left(V_i,V_i-1\right)\in E$ 及 $\left(V_1,V_N\right)\in E$。输入的数据保证 $100%$ 的数据满足 $T\leq100,3\leq N\leq200,M\leq10000$。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>包含 $T$ 行，若输入文件的第 $i$ 组数据所对应图是平面图，则在第 $i$ 行输出 $\text{YES}$，否则在第 $i$ 行输出 $\text{NO}$，注意均为大写字母</p>
<h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6 9</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">1 4 2 5 3 6</span><br><span class="line">5 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 1</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><img src="/2024/05/31/2-sat%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/image-20230405092428295.png" class="" title="图1">

<p>假设黑线是哈密顿环的一部分，红线是除了环之外的其他边，假设所有的边都在环的内部（上图），如果发现两条边相交，我们一定可以把其中一条边画在环的外部从而避免相交（下图），于是我们的$2-sat$模型就是所有两两相交的边，不能同时出现在内部或者外部（如果在内部相交，那么在外部也一定会相交）。</p>
<img src="/2024/05/31/2-sat%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/image-20230405092857122.png" class="" title="图2">

<p>接下来要思考的是如何判断两条边必相交，其实只要按照哈密顿环上点的顺序给$V$ 编号，然后判断两条边是否有交叉区域即可。</p>
<img src="/2024/05/31/2-sat%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/image-20230405093822138.png" class="" title="图3">

<img src="/2024/05/31/2-sat%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/image-20230405093855294.png" class="" title="图4">

<p>如上图，相交一共两种情况，注意构成哈密顿环的边是不参与比较的。</p>
<p>现在给出此题的 $2-sat$ 模型，定义：$x$ 为在环内的边，$\neg x$ 在环外的边，对于不属于哈密顿环的不同的两条边$a,b$，如果相交，则有如下关系：<br>$$<br>a \to \neg b，\neg a \to b， b \to \neg a ，\neg b \to a<br>$$<br>还有一个平面图的性质: $m&lt;&#x3D;3n-6$  </p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">7</span>, M = <span class="number">2e5</span> + <span class="number">7</span>, V = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[<span class="number">4</span> * V], e[M], ne[M], idx = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  e[idx] = b;</span><br><span class="line">  ne[idx] = h[a];</span><br><span class="line">  h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;PII;</span><br><span class="line">PII edge[N];</span><br><span class="line"><span class="type">int</span> hmd[V];</span><br><span class="line"><span class="type">bool</span> is_hmd[V][V];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], times;</span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"><span class="type">int</span> scc[N], sid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++times;</span><br><span class="line">  stk[++top] = u;</span><br><span class="line">  in_stk[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="keyword">if</span> (!dfn[j]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(j);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[j], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(dfn[j], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    ++sid;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = stk[top--];</span><br><span class="line">      in_stk[p] = <span class="literal">false</span>;</span><br><span class="line">      scc[p] = sid;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span><span class="comment">//相交返回true </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ax = hmd[edge[i].x], ay = hmd[edge[i].y];</span><br><span class="line">  <span class="type">int</span> bx = hmd[edge[j].x], by = hmd[edge[j].y];</span><br><span class="line">  <span class="keyword">if</span> (bx &gt; ax &amp;&amp; bx &lt; ay &amp;&amp; by &gt; ay) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (by &gt; ax &amp;&amp; by &lt; ay &amp;&amp; bx &lt; ax) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">  <span class="built_in">memset</span>(is_hmd, <span class="number">0</span>, <span class="keyword">sizeof</span> is_hmd);</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">  <span class="built_in">memset</span>(in_stk, <span class="number">0</span>, <span class="keyword">sizeof</span> stk);</span><br><span class="line">  idx = <span class="number">1</span>; times = <span class="number">0</span>; top = <span class="number">0</span>; sid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    edge[i] = &#123; a,b &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); hmd[a] = <span class="number">1</span>;<span class="comment">//存下当前下标是哈密顿路径的第几个点</span></span><br><span class="line">  <span class="type">int</span> first = a;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b); hmd[b] = i;</span><br><span class="line">    is_hmd[a][b] = is_hmd[b][a] = <span class="literal">true</span>;<span class="comment">//a,b之间的路径是哈密顿路径</span></span><br><span class="line">    a = b;</span><br><span class="line">  &#125;</span><br><span class="line">  is_hmd[first][a] = is_hmd[a][first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m &gt; <span class="number">3</span> * n - <span class="number">6</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="comment">//要将原图转换2-sat模型，首先排除掉哈密顿环上的边</span></span><br><span class="line">    <span class="keyword">if</span> (is_hmd[edge[i].x][edge[i].y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (hmd[edge[i].x] &lt; hmd[edge[i].y]) edge[++cnt] = edge[i];</span><br><span class="line">    <span class="keyword">else</span> edge[++cnt] = &#123; edge[i].y,edge[i].x &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  m = cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check</span>(i, j)) &#123;<span class="comment">//判断边i,j是否相交，在此之前已经保证不存在哈密顿环的边</span></span><br><span class="line">        <span class="built_in">add</span>(i, j + m); <span class="built_in">add</span>(i + m, j);</span><br><span class="line">        <span class="built_in">add</span>(j, i + m); <span class="built_in">add</span>(j + m, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scc[i] == scc[i + m]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">solve</span>()) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原图转化$2-sat$ 是根据有相交的边而转化的，根据$m&lt;&#x3D;3n-6$ ,$n&lt;&#x3D;200$ ,假设有”矛盾“的边有400条，转$2-sat$模型后，会有$400*2$个节点（每个节点都有对应的$i+m$）,假设每条边都相交，最多有 $400*400&#x3D;160000$ 个交点，也就是$2-sat$有十六万条有向边。</p>
<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>VM初始化linux网络配置</title>
    <url>/2024/05/30/VM%E5%88%9D%E5%A7%8B%E5%8C%96linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>每次建虚机都先配半天网络，记录下脚本来直接一键解决</p>
<span id="more"></span>
<p>固定IP配置时有坑，一般认为网关是1，但是VM默认是2，可以通过<code>ip route</code>查看默认网关后，再固定ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~# ip route</span><br><span class="line">default via 192.168.137.2 dev ens33 proto static </span><br></pre></td></tr></table></figure>
<p>可以看到默认网关是<code>192.168.137.2</code></p>
<p>现在正式开始，先声明几个临时变量，一般我们都不会修改原ip，使用<code>ip addr</code>可查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line"># 指定ip</span><br><span class="line">ip=192.168.137.123</span><br><span class="line"># 网关</span><br><span class="line">gw=192.168.137.2</span><br><span class="line"># 网卡名称，可通过ip addr查看</span><br><span class="line">NC=ens33</span><br></pre></td></tr></table></figure>
<p>执行脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清华源</span><br><span class="line">rm /etc/apt/sources.list</span><br><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt; EOF</span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt-get update -y</span><br><span class="line"></span><br><span class="line"># 固定ip</span><br><span class="line">rm /etc/netplan/00-installer-config.yaml</span><br><span class="line">cat &gt;&gt; /etc/netplan/00-installer-config.yaml  &lt;&lt; EOF</span><br><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    $&#123;NC&#125;:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      addresses:</span><br><span class="line">        - $&#123;ip&#125;/24</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [$&#123;gw&#125;]</span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: $&#123;gw&#125;</span><br><span class="line">  version: 2</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">netplan apply</span><br><span class="line"></span><br><span class="line"># 允许服务器被root身份连接</span><br><span class="line">cat &gt;&gt; /etc/ssh/sshd_config &lt;&lt; EOF </span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PermitEmptyPasswords yes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl reload sshd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>linux磁盘管理</title>
    <url>/2024/05/30/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>一文教会你怎么管理磁盘</p>
<span id="more"></span>
<h1 id="linux磁盘管理"><a href="#linux磁盘管理" class="headerlink" title="linux磁盘管理"></a>linux磁盘管理</h1><h2 id="1-为什么要分区"><a href="#1-为什么要分区" class="headerlink" title="1 为什么要分区"></a>1 为什么要分区</h2><p><strong>易于管理和使用</strong></p>
<p>比如说我们把磁盘分了sda1、sda2、sda3、sda4盘，我们假设sda1盘为系统盘，其他的比如说游戏、办公、软件盘，电脑搜索文件时只需要在相对应的分区搜索就可以了，没必要进行全盘搜索。大大节省了寻找文件的时间</p>
<p><strong>有利于数据的安全</strong></p>
<p>通过分区可以降低数据损失的风险。出现硬盘坏道、错误操作、重装系统都有可能造成数据损失，如果分区了，那么我们就可以将损失最小化。</p>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2 相关概念"></a>2 相关概念</h2><p><strong>磁盘</strong> Disk 计算机的外部存储器设备</p>
<p><strong>分区</strong> Disk Partition 分区是在磁盘上划分出来的一块独立的区域</p>
<p>主分区（Primary Partition）：主分区是硬盘的启动分区，它是独立的，在一个物理磁盘(disk)上，最多只能有四个主分区</p>
<p>扩展分区（Extended Partition）：扩展分区是除主分区外，硬盘上剩下的空间所建立起来的分区。扩展分区不能直接使用，它需要以逻辑分区的方式来使用，所以说扩展分区可以分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分</p>
<p><strong>物理卷</strong> PV 这也是一个磁盘分区，它可以更灵活地被划分和组合。可以将多个物理卷组合成一个卷组，然后在卷组上创建一个或多个逻辑卷。逻辑卷的大小可以随时调整，而不受物理卷的位置或大小的限制</p>
<p><strong>卷组</strong> vg是一个或多个物理卷的组合，相当于是一个存储资源池</p>
<p><strong>逻辑卷</strong> Logical Volume 这是卷组中抽象出来的一个磁盘空间</p>
<p><strong>格式化</strong> 将分区格式化成不同的文件系统，常用的有ext4, xfs</p>
<p><strong>文件系统</strong> linux系统中”一切皆文件”，文件系统决定了如何在磁盘&#x2F;分区上对文件进行命名、存储、和检索</p>
<p><strong>挂载</strong> 我们无法直接访问磁盘中的文件，必须指定一个本地的一个文件目录关联到目标磁盘上的文件系统，通过指定的本地的文件目录才能直接查看磁盘中的文件，这个文件目录成为挂载点，这个行为称为挂载</p>
<p>这张图清晰的说明了磁盘的管理层次：</p>
<img src="/2024/05/30/linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/linuxDiskManage.png" class="" title="linux磁盘管理">

<h2 id="3-查看磁盘信息"><a href="#3-查看磁盘信息" class="headerlink" title="3 查看磁盘信息"></a>3 查看磁盘信息</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>disk filesystem 磁盘文件系统，用于显示文件系统的磁盘空间使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">tmpfs 388M 2.0M 386M 1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv 18G 12G 5.0G 71% /</span><br><span class="line">tmpfs 1.9G 0 1.9G 0% /dev/shm</span><br><span class="line">tmpfs 5.0M 4.0K 5.0M 1% /run/lock</span><br><span class="line">/dev/sda2 1.8G 381M 1.3G 24% /boot</span><br><span class="line">tmpfs 388M 120K 388M 1% /run/user/1000</span><br><span class="line">/dev/sr0 2.0G 2.0G 0 100% /media/xhs/Ubuntu-Server 22.04.3 LTS amd64</span><br></pre></td></tr></table></figure>

<p>&#x2F;run：这是一个tmpfs文件系统，tmpfs是基于内存的文件系统，可以使用内存或swap分区来存储文件，读写速度非常快。</p>
<p>&#x2F;：这是主文件系统，它是一个逻辑卷（&#x2F;dev&#x2F;mapper&#x2F;ubuntu–vg-ubuntu–lv）</p>
<p>&#x2F;dev&#x2F;shm：这是一个共享内存tmpfs，使用RAM作为存储介质，读写速度非常快</p>
<p>&#x2F;run&#x2F;lock：这是一个tmpfs文件系统，用于存储锁文件</p>
<p>&#x2F;boot：俗称启动盘（&#x2F;dev&#x2F;sda2），包含了启动linux系统所需的一些重要文件</p>
<p>&#x2F;run&#x2F;user&#x2F;1000：这是一个tmpfs文件系统，用于存储用户级别的session数据</p>
<p>&#x2F;media&#x2F;xhs&#x2F;Ubuntu-Server 22.04.3 LTS amd64：这是光盘驱动器（&#x2F;dev&#x2F;sr0），一个Ubuntu Server 22.04.3 LTS的安装光盘。</p>
<blockquote>
<p> 随机访问存储（Random Access Memory，简称RAM）是计算机中的一种主要存储设备。它可以快速读取和写入数据，并且能够随机访问任意位置的存储单元，因此被称为”随机访问存储”。RAM一般用于存储正在运行的程序、数据和操作系统等信息，RAM具有快速读取和写入数据的能力，可以使计算机更快地执行操作。RAM可以被认为是一种短期存储，因为当计算机关闭时，RAM中的所有数据都会被清除。</p>
</blockquote>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>Disk Usage 磁盘使用情况，用于检查文件和目录的磁盘使用信息，显示的是文件和目录占用信息，而不是它们实际使用的空间，例如，如果文件系统的块大小是4KB，那么即使创建一个只有1字节的文件，文件系统也会为这个文件预留4KB的空间。du命令显示的文件大小可能会大于文件实际的大小。</p>
<p>du 会显示出所有挂载的文件系统的空间使用情况</p>
<p>-s 只显示总计，-h 以人类可读的格式显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh ./cloud-deploy</span><br><span class="line">300K cloud-deploy</span><br><span class="line"></span><br><span class="line">du -h ./cloud-deploy</span><br><span class="line">8.0K ./cloud-deploy/.git/info</span><br><span class="line">8.0K ./cloud-deploy/.git/refs/remotes/origin</span><br><span class="line">12K ./cloud-deploy/.git/refs/remotes</span><br><span class="line">4.0K ./cloud-deploy/.git/refs/tags</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h3><p>用于列出所有块设备信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设备名称 主设备号:次设备号 可移动设备 只读 类型 挂载点</span><br><span class="line">NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0 7:0 0 4K 1 loop /snap/bare/5</span><br><span class="line">loop2 7:2 0 74.1M 1 loop /snap/core22/1033</span><br><span class="line">loop3 7:3 0 63.5M 1 loop /snap/core20/2015</span><br><span class="line">...</span><br><span class="line">loop10 7:10 0 40.4M 1 loop /snap/snapd/20671</span><br><span class="line">sda 8:0 0 20G 0 disk</span><br><span class="line">├─sda1 8:1 0 1M 0 part</span><br><span class="line">├─sda2 8:2 0 1.8G 0 part /boot</span><br><span class="line">└─sda3 8:3 0 18.2G 0 part</span><br><span class="line">└─ubuntu--vg-ubuntu--lv 253:0 0 18.2G 0 lvm /</span><br><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">sr0 11:0 1 2G 0 rom /media/xhs/Ubuntu-Server 22.04.3 LTS amd64</span><br></pre></td></tr></table></figure>


<blockquote>
<p>主设备号：主设备号用于标识设备的类型。例如，所有的SCSI硬盘设备都有相同的主设备号。<br>次设备号：次设备号用于标识同一类型的设备中的特定设备。例如，第一个SCSI硬盘的次设备号是0，第二个SCSI硬盘的次设备号是1，以此类推。</p>
</blockquote>
<h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>可以是Fixed Disk也可以是Format Disk，用来查看、创建、删除、检查磁盘分区</p>
<p>-l 列出所有分区表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~# fdisk -l</span><br><span class="line">Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Disk model: VMware Virtual S # 磁盘的型号。在这种情况下，它是一个VMware虚拟磁盘。</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes # 每个扇区是512字节</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes # 逻辑扇区和物理扇区的大小</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes # 最小和最优的I/O大小</span><br><span class="line">Disklabel type: gpt # 磁盘标签的类型。GPT（GUID Partition Table）。</span><br><span class="line">Disk identifier: D1840A28-5A7D-4F13-8495-D55FDDF187F7 # 磁盘的唯一标识符</span><br><span class="line"></span><br><span class="line">设备 开始扇区 结束扇区 扇区总数</span><br><span class="line">Device Start End Sectors Size Type</span><br><span class="line">/dev/sda1 2048 4095 2048 1M BIOS boot</span><br><span class="line">/dev/sda2 4096 3719167 3715072 1.8G Linux filesystem</span><br><span class="line">/dev/sda3 3719168 41940991 38221824 18.2G Linux filesystem</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="pvs"><a href="#pvs" class="headerlink" title="pvs"></a>pvs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PV VG Fmt Attr PSize PFree</span><br><span class="line">/dev/sda3 ubuntu-vg lvm2 a-- 18.22g 0</span><br><span class="line">/dev/sdb1 vg156 lvm2 a-- 1020.00m 0</span><br><span class="line">/dev/sdb3 vg0 lvm2 a-- &lt;3.00g &lt;2.00g</span><br><span class="line">/dev/sdb5 vg156 lvm2 a-- 1020.00m 1012.00m</span><br><span class="line">/dev/sdb6 vg156 lvm2 a-- &lt;2.00g 0</span><br></pre></td></tr></table></figure>

<p>pvdisplay 查看更详细的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Physical volume </span><br><span class="line">PV Name /dev/sdb3</span><br><span class="line">VG Name vg0</span><br><span class="line">PV Size 3.00 GiB / not usable 4.00 MiB</span><br><span class="line">Allocatable yes</span><br><span class="line">PE Size 4.00 MiB</span><br><span class="line">Total PE 767</span><br><span class="line">Free PE 511</span><br><span class="line">Allocated PE 256</span><br><span class="line">PV UUID K9XGZP-Wj8m-okSb-Bd7l-aiRS-iOMr-Mswu56</span><br></pre></td></tr></table></figure>

<h3 id="vgs"><a href="#vgs" class="headerlink" title="vgs"></a>vgs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VG #PV #LV #SN Attr VSize VFree</span><br><span class="line">ubuntu-vg 1 1 0 wz--n- 18.22g 0</span><br><span class="line">vg0 1 1 0 wz--n- &lt;3.00g &lt;2.00g</span><br><span class="line">vg156 3 1 0 wz--n- &lt;3.99g 1012.00m</span><br></pre></td></tr></table></figure>

<p>PV 物理卷数量</p>
<p>LV 逻辑卷数量</p>
<p>SN 快照数量</p>
<p>Attr 卷组属性，表示此卷组可读写（w），大小可调整（z），没有 RAID（-），没有部分模式（-），没有集群（n），没有内部策略（-）</p>
<p>vgdisplay 查看更详细的信息</p>
<h3 id="lvs"><a href="#lvs" class="headerlink" title="lvs"></a>lvs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert</span><br><span class="line">ubuntu-lv ubuntu-vg -wi-ao 18.22g</span><br><span class="line">lv0 vg0 -wi-a- 1.00g</span><br><span class="line">lv156 vg156 -wi-a- 3.00g</span><br></pre></td></tr></table></figure>

<p>lvdisplay 查看更详细的信息</p>
<h2 id="4-添加"><a href="#4-添加" class="headerlink" title="4 添加"></a>4 添加</h2><h3 id="添加partition"><a href="#添加partition" class="headerlink" title="添加partition"></a>添加partition</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~# fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.37.2).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">Created a new DOS disklabel with disk identifier 0x868fc991.</span><br><span class="line"></span><br><span class="line">Command (m for help): m # 查看帮助</span><br><span class="line"></span><br><span class="line">Help:</span><br><span class="line"></span><br><span class="line">DOS (MBR)</span><br><span class="line">a toggle a bootable flag</span><br><span class="line">b edit nested BSD disklabel</span><br><span class="line">c toggle the dos compatibility flag</span><br><span class="line"></span><br><span class="line">Generic</span><br><span class="line">d delete a partition</span><br><span class="line">F list free unpartitioned space</span><br><span class="line">l list known partition types</span><br><span class="line">n add a new partition</span><br><span class="line">p print the partition table</span><br><span class="line">t change a partition type</span><br><span class="line">v verify the partition table</span><br><span class="line">i print information about a partition</span><br><span class="line"></span><br><span class="line">Misc</span><br><span class="line">m print this menu</span><br><span class="line">u change display/entry units</span><br><span class="line">x extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">Script</span><br><span class="line">I load disk layout from sfdisk script file</span><br><span class="line">O dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">Save &amp; Exit</span><br><span class="line">w write table to disk and exit</span><br><span class="line">q quit without saving changes</span><br><span class="line"></span><br><span class="line">Create a new label</span><br><span class="line">g create a new empty GPT partition table</span><br><span class="line">G create a new empty SGI (IRIX) partition table</span><br><span class="line">o create a new empty DOS partition table</span><br><span class="line">s create a new empty Sun partition table</span><br><span class="line"></span><br><span class="line">Command (m for help): n # 创建分区</span><br><span class="line">Partition type</span><br><span class="line">p primary (0 primary, 0 extended, 4 free)</span><br><span class="line">e extended (container for logical partitions)</span><br><span class="line">Select (default p): # 默认创建主分区</span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (1-4, default 1): 默认分区号是1</span><br><span class="line">First sector (2048-41943039, default 2048): # 默认开始扇区是2048</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-41943039, default 41943039): +1G # 选择结束扇区，这里使用+1G表示创建1G空间，默认选项会将所有空间用于创建分区</span><br><span class="line"></span><br><span class="line">Created a new partition 1 of type &#x27;Linux&#x27; and of size 1 GiB.</span><br><span class="line"></span><br><span class="line">Command (m for help): p # 查看分区信息，</span><br><span class="line">Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x868fc991</span><br><span class="line"></span><br><span class="line">Device Boot Start End Sectors Size Id Type</span><br><span class="line">/dev/sdb1 2048 2099199 2097152 1G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): wq # w保存，q退出</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再创建三个主分区，大小分别为2、3、4G</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x868fc991</span><br><span class="line"></span><br><span class="line">Device Boot Start End Sectors Size Id Type</span><br><span class="line">/dev/sdb1 2048 2099199 2097152 1G 83 Linux</span><br><span class="line">/dev/sdb2 2099200 6293503 4194304 2G 83 Linux</span><br><span class="line">/dev/sdb3 6293504 12584959 6291456 3G 83 Linux</span><br><span class="line">/dev/sdb4 12584960 20973567 8388608 4G 83 Linux</span><br></pre></td></tr></table></figure>


<p>此时再想创建，就会提示不能创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">To create more partitions, first replace a primary with an extended partition.</span><br></pre></td></tr></table></figure>


<p>必须将主分区替换为扩展分区，扩展分区可以包含多个逻辑分区，将刚刚创建的4号分区删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): d</span><br><span class="line">Partition number (1-4, default 4):</span><br><span class="line"></span><br><span class="line">Partition 4 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type</span><br><span class="line">p primary (0 primary, 0 extended, 4 free)</span><br><span class="line">e extended (container for logical partitions)</span><br><span class="line">Select (default p): e # 选择e即可，接下来流程都一样</span><br></pre></td></tr></table></figure>


<p>之后创建的分区都称为逻辑分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x868fc991</span><br><span class="line"></span><br><span class="line">Device Boot Start End Sectors Size Id Type</span><br><span class="line">/dev/sdb1 2048 2099199 2097152 1G 83 Linux</span><br><span class="line">/dev/sdb2 2099200 6293503 4194304 2G 83 Linux</span><br><span class="line">/dev/sdb3 6293504 12584959 6291456 3G 83 Linux</span><br><span class="line">/dev/sdb4 12584960 20973567 8388608 4G 5 Extended</span><br><span class="line">/dev/sdb5 12587008 14684159 2097152 1G 83 Linux</span><br><span class="line">/dev/sdb6 14686208 18880511 4194304 2G 83 Linux</span><br></pre></td></tr></table></figure>


<p>lsblk 发现sdb4只有1k</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part</span><br><span class="line">├─sdb2 8:18 0 2G 0 part</span><br><span class="line">├─sdb3 8:19 0 3G 0 part</span><br><span class="line">├─sdb4 8:20 0 1K 0 part</span><br><span class="line">├─sdb5 8:21 0 1G 0 part</span><br><span class="line">└─sdb6 8:22 0 2G 0 part</span><br></pre></td></tr></table></figure>


<p>扩展分区本身并不包含任何数据，它只是一个容器，用于包含逻辑分区（如&#x2F;dev&#x2F;sdb5和&#x2F;dev&#x2F;sdb6）。因此，扩展分区的大小显示为1K，这只是一个占位符，表示这是一个扩展分区，而不是实际的数据分区。实际的数据存储在逻辑分区中，可以看到&#x2F;dev&#x2F;sdb5和&#x2F;dev&#x2F;sdb6各有1G和2G的存储空间。</p>
<blockquote>
<p> 只能拥有一个扩展分区，所有逻辑分区都被挂在扩展分区下面，逻辑分区的大小总和不能超过扩展分区(上文中是4G)</p>
</blockquote>
<h3 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sdb3</span><br></pre></td></tr></table></figure>


<h3 id="创建卷组"><a href="#创建卷组" class="headerlink" title="创建卷组"></a>创建卷组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgcreate vg0 /dev/sdb3</span><br></pre></td></tr></table></figure>


<h3 id="创建lvm"><a href="#创建lvm" class="headerlink" title="创建lvm"></a>创建lvm</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvcreate -n lv0 -L 1G vg0</span><br><span class="line"># -n 指定名称 -L 指定大小</span><br></pre></td></tr></table></figure>


<p>lsblk 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part</span><br><span class="line">├─sdb2 8:18 0 2G 0 part</span><br><span class="line">├─sdb3 8:19 0 3G 0 part</span><br><span class="line">│ └─vg0-lv0 253:1 0 1G 0 lvm</span><br></pre></td></tr></table></figure>


<h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定一个用于挂载的目录</span><br><span class="line">mkdir -p /mnt/lv0</span><br><span class="line"></span><br><span class="line"># 将逻辑卷初始化为ext4</span><br><span class="line">mkfs.ext4 /dev/vg0/lv0</span><br><span class="line"></span><br><span class="line"># 挂载</span><br><span class="line">mount /dev/vg0/lv0 /mnt/lv0/</span><br><span class="line"></span><br><span class="line"># part也能进行挂载，同样需要先初始化，然后挂载到一个目录即可</span><br><span class="line">mount /dev/sdb1 /mnt/lv1/</span><br></pre></td></tr></table></figure>


<p>lsblk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part /mnt/lv1</span><br><span class="line">├─sdb2 8:18 0 2G 0 part</span><br><span class="line">├─sdb3 8:19 0 3G 0 part</span><br><span class="line">│ └─vg0-lv0 253:1 0 1G 0 lvm /mnt/lv0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>在&#x2F;mnt&#x2F;lv1和&#x2F;mnt&#x2F;lv0目录中写一些文件，使用df查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/mapper/vg0-lv0 974M 257M 650M 29% /mnt/lv0</span><br><span class="line">/dev/sdb1 974M 514M 393M 57% /mnt/lv1</span><br></pre></td></tr></table></figure>

<p>mount是临时挂载，实现永久挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /etc/fstab &lt;&lt; EOF</span><br><span class="line">/dev/vg0/lv0 /mnt/lv0/ ext4 defaults 0 0</span><br><span class="line">EOF</span><br><span class="line"># 参数解释，从左往右分别为：</span><br><span class="line"># 要挂载的设备 挂载点 文件系统类型 挂载选项(选默认选项)</span><br><span class="line"># 第一个0 是dump备份的参数。0表示不备份，1表示需要备份。</span><br><span class="line"># 第二个0 是文件系统检查的顺序。0表示不检查，1表示首先检查（通常用于根文件系统），2表示接下来检查（用于非根文件系统）默认设置为0就好了</span><br></pre></td></tr></table></figure>

<h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h2><p>必须按照和创建相反的顺序删除分区。直接使用fdisk删除sdb3会发生这种事情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">Device Boot Start End Sectors Size Id Type</span><br><span class="line">/dev/sdb1 2048 2099199 2097152 1G 83 Linux</span><br><span class="line">/dev/sdb2 2099200 6293503 4194304 2G 83 Linux</span><br><span class="line">/dev/sdb4 12584960 20973567 8388608 4G 5 Extended</span><br><span class="line">/dev/sdb5 12587008 14684159 2097152 1G 83 Linux</span><br><span class="line">/dev/sdb6 14686208 18880511 4194304 2G 83 Linux</span><br><span class="line"></span><br><span class="line">lsblk</span><br><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part /mnt/lv1</span><br><span class="line">├─sdb2 8:18 0 2G 0 part</span><br><span class="line">├─sdb3 8:19 0 3G 0 part</span><br><span class="line">│ └─vg0-lv0 253:1 0 1G 0 lvm /mnt/lv0</span><br><span class="line">├─sdb4 8:20 0 512B 0 part</span><br><span class="line">├─sdb5 8:21 0 1G 0 part</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>可以看到两个命令的结果不一致，事实上除了fdisk外，其它的命令都显示sdb3仍然还在，所以sdb3根本没有被删除，这种不一致不好好处理会产生更大的麻烦，最好按以下顺序删除：</p>
<h3 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># umount &lt;挂载点&gt;</span><br><span class="line">umount /mnt/lv0/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果提示挂载点被占用，可以使用 lsof &#x2F;mnt&#x2F;lv0&#x2F; 查看有什么进程在使用，并可以选择kill它们<br>强制卸载命令：umount -l &#x2F;mnt&#x2F;lv0</p>
</blockquote>
<h3 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvremove /dev/vg0/lv0</span><br></pre></td></tr></table></figure>

<h3 id="删除卷组"><a href="#删除卷组" class="headerlink" title="删除卷组"></a>删除卷组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgremove /dev/vg0</span><br></pre></td></tr></table></figure>


<h3 id="删除物理卷"><a href="#删除物理卷" class="headerlink" title="删除物理卷"></a>删除物理卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pvremove /dev/sdb3</span><br></pre></td></tr></table></figure>


<h3 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Command (m for help): d</span><br><span class="line">  Partition number (1-6, default 6): 3</span><br><span class="line">  </span><br><span class="line">  Partition 3 has been deleted.</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 如果还是提示不能删除，那么使用 partprobe 更新分区表</p>
</blockquote>
<h2 id="6-扩容"><a href="#6-扩容" class="headerlink" title="6 扩容"></a>6 扩容</h2><p>fdisk扩容必须确保当前分区后面没有其它分区。</p>
<p>先使用d删除分区，然后用n创建更大的分区，而且新分区的起始位置必须和原分区的起始位置相同，否则会丢失数据。这一步就不演示了。</p>
<p>扩大分区后， 还需要扩大文件系统的空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb`</span><br><span class="line"># d 删除3, 4, 5 6号分区</span><br><span class="line"># n 创建更大的3号分区</span><br><span class="line"></span><br><span class="line"># 扩大文件系统的空间</span><br><span class="line">resize2fs /dev/sdb3</span><br></pre></td></tr></table></figure>


<p>扩容不能跨区这点很麻烦，假如4，5，6号分区有数据不能删除，那3号分区就无法扩容，gparted可以调整其它分区的大小，但是gparted是图形化工具，使用的情况有限。</p>
<p>卷组可以解决这个情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsblk</span><br><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part</span><br><span class="line">...</span><br><span class="line">├─sdb5 8:21 0 1G 0 part</span><br><span class="line">└─sdb6 8:22 0 2G 0 part</span><br><span class="line"></span><br><span class="line"># 创建物理卷</span><br><span class="line">pvcreate /dev/sdb1</span><br><span class="line">pvcreate /dev/sdb5</span><br><span class="line">pvcreate /dev/sdb6</span><br><span class="line"></span><br><span class="line"># 创建卷组</span><br><span class="line">vgcreate vg156 /dev/sdb1 /dev/sdb5 /dev/sdb6</span><br><span class="line"># 已有的卷组可以添加物理卷</span><br><span class="line">vgextend vg156 /dev/sdb2</span><br><span class="line"></span><br><span class="line"># 创建lvm</span><br><span class="line">lvcreate -n lv156 -L 1G vg156</span><br><span class="line"></span><br><span class="line">lsblk</span><br><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part</span><br><span class="line">...</span><br><span class="line">├─sdb5 8:21 0 1G 0 part</span><br><span class="line">└─sdb6 8:22 0 2G 0 part</span><br><span class="line">└─vg156-lv156 253:2 0 1G 0 lvm</span><br><span class="line"></span><br><span class="line"># 可以随时给lvm扩容</span><br><span class="line">lvextend -L 3G /dev/vg156/lv156</span><br><span class="line"></span><br><span class="line">lsblk</span><br><span class="line">sdb 8:16 0 20G 0 disk</span><br><span class="line">├─sdb1 8:17 0 1G 0 part</span><br><span class="line">│ └─vg156-lv156 253:2 0 3G 0 lvm</span><br><span class="line">...</span><br><span class="line">├─sdb5 8:21 0 1G 0 part</span><br><span class="line">│ └─vg156-lv156 253:2 0 3G 0 lvm</span><br><span class="line">└─sdb6 8:22 0 2G 0 part</span><br><span class="line">└─vg156-lv156 253:2 0 3G 0 lvm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<!-- <div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'linux1', // 可选。默认为 location.href
  owner: 'xuehuasu',
  repo: 'xuehuasu.github.io',
  oauth: {
    client_id: 'Ov23ctteY5rA6HskBCFV',
    client_secret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  },
  language: en,
})
gitment.render('container')
</script> -->


<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>存储</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>vim与bash常用命令</title>
    <url>/2024/05/31/vim%E4%B8%8Ebash%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>vim写bash脚本常用到的操作</p>
<span id="more"></span>
<h1 id="vim与bash常用命令"><a href="#vim与bash常用命令" class="headerlink" title="vim与bash常用命令"></a>vim与bash常用命令</h1><h2 id="vim-部分"><a href="#vim-部分" class="headerlink" title="vim 部分"></a>vim 部分</h2><h3 id="tab设置为4空格"><a href="#tab设置为4空格" class="headerlink" title="tab设置为4空格"></a>tab设置为4空格</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim默认8个空格的距离，格式很难看</span></span><br><span class="line">vim ~/.vimrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br></pre></td></tr></table></figure>



<h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><p>在 Vim 中，使用块选择模式（Visual Block Mode）来同时在多行中插入相同的内容。</p>
<ol>
<li>导航到你想要开始选择的行和列。</li>
<li>按 <code>Ctrl + v</code> 进入块选择模式。</li>
<li>使用方向键或者 <code>j</code> 和 <code>k</code> 来选择多行。</li>
<li>按 <code>I</code>（大写的 i）进入插入模式。</li>
<li>输入想要插入的内容。</li>
<li>按 <code>Esc</code> 退出插入模式。刚才输入的内容会被插入到所有选中的行中。</li>
</ol>
<h3 id="vim多窗口"><a href="#vim多窗口" class="headerlink" title="vim多窗口"></a>vim多窗口</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:sp <span class="comment"># 上下分割</span></span><br><span class="line">:vsp <span class="comment"># 左右分割</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>Ctrl + w</code> 然后按 <code>h</code>、<code>j</code>、<code>k</code> 或 <code>l</code> 来在不同的窗口之间切换。这些键对应于左、下、上和右方向。</p>
<p>当然我们也可以用tmux或者不用vim(bushi</p>
<h3 id="快速删除"><a href="#快速删除" class="headerlink" title="快速删除"></a>快速删除</h3><p>在 Vim 中，你可以使用 <code>4dd</code> 来删除当前行以及接下来的三行。这里的 <code>4</code> 表示四行，<code>dd</code> 是删除命令</p>
<ul>
<li><code>dd</code>：剪切当前行。</li>
<li><code>D</code>：剪切从光标位置到行尾的内容。</li>
<li><code>d$</code>：剪切从光标位置到行尾的内容（与<code>D</code>命令相同）。</li>
<li><code>d0</code>：剪切从光标位置到行首的内容。</li>
<li><code>dw</code>：剪切从光标位置到下一个单词开头的内容。</li>
<li><code>d2w</code>：剪切从光标位置开始的两个单词（<code>2</code>可以替换为任何数字，表示剪切的单词数）。</li>
<li><code>dG</code>：剪切从光标位置到文件末尾的所有行。</li>
<li><code>d1G</code>：剪切从光标位置到文件开头的所有行。</li>
</ul>
<h3 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h3><p><code>0</code> 定位到行头</p>
<p><code>$</code>定位到行尾</p>
<p><code>A</code>定位到行末并进入insert模式</p>
<p><code>O</code>插入上一行</p>
<p><code>o</code> 插入下一行</p>
<p><code>h</code> <code>j</code> <code>k</code> <code>l</code> 分别对应光标的左下上右移动，向下移动10行就是<code>10k</code> </p>
<h2 id="shell-部分"><a href="#shell-部分" class="headerlink" title="shell 部分"></a>shell 部分</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>bash中有些地方必须使用空格，有些地方禁止使用空格</p>
<ol>
<li>赋值操作不能不使用空格，<code>var=value</code></li>
<li>测试表达式[]和[[]]，表达式和括号之间必须有空格，<code>[ $var -ne 0 ]</code></li>
<li>算数表达式()(())，不用在意空格有无</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title="&amp;"></a>&amp;</h3><p>在两个命令之间使用 <code>&amp;</code> 时，第一个命令会立即开始执行，然后 shell 不会等待它完成就立即开始执行第二个命令。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">command1 &amp; command2</span><br></pre></td></tr></table></figure>

<p><code>command2</code>会立即执行，<code>command1</code>会被放在后台执行</p>
<h3 id="文件输入重定向"><a href="#文件输入重定向" class="headerlink" title="文件输入重定向"></a>文件输入重定向</h3><p>单行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; filename</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span> | <span class="built_in">tee</span> filename <span class="comment"># 覆盖</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span> | <span class="built_in">tee</span> -a filename <span class="comment"># 追加</span></span><br></pre></td></tr></table></figure>

<p>多行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追加</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; filename &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string"> Hello</span></span><br><span class="line"><span class="string"> i&#x27;m</span></span><br><span class="line"><span class="string">   lihua</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 覆盖</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; filename &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">  Hello</span></span><br><span class="line"><span class="string"> i&#x27;m</span></span><br><span class="line"><span class="string">   lihua</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用echo+\n</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;  Hello\n\</span></span><br><span class="line"><span class="string"> i&#x27;m\n\</span></span><br><span class="line"><span class="string">   lihua&quot;</span>\</span><br><span class="line">&gt; filename</span><br><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;  Hello\n i&#x27;m\n   lihua&quot;</span> &gt; filename</span><br></pre></td></tr></table></figure>



<h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line">file=<span class="string">&quot;/path/to/your/file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -f <span class="variable">$file</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File does not exist&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;File exists&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>



<h3 id="-1"><a href="#-1" class="headerlink" title="$()"></a>$()</h3><p>()创建子shell,可以在内部执行shell，$返回结果，很有趣</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以轻易的将文件内容取出并赋值给变量</span></span><br><span class="line">content=$(<span class="built_in">cat</span> filename) </span><br><span class="line"><span class="comment"># 遍历ls的执行结果</span></span><br><span class="line"><span class="keyword">for</span> pool <span class="keyword">in</span> $(ceph osd pool <span class="built_in">ls</span>)</span><br><span class="line"><span class="comment"># 还可以嵌套执行，比如取出key:value</span></span><br><span class="line">value=$(<span class="built_in">echo</span> $(grep -w key filename) | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f2)</span><br></pre></td></tr></table></figure>



<h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>一些基本的<code>cut</code>命令的使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -b --bytes</span></span><br><span class="line"><span class="comment"># 提取第五个字节</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;how-to geek&#x27;</span> | <span class="built_in">cut</span> -b 5</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取从第5个字节到第11个字节</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;how-to geek&#x27;</span> | <span class="built_in">cut</span> -b 5-11</span><br><span class="line"><span class="comment"># to geek</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -f --fields</span></span><br><span class="line"><span class="comment"># 提取第二个字段，并用-d指定分隔符是&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a multi word string&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 2</span><br><span class="line"><span class="comment"># 也可指定其它分隔符&#x27;,&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;one,two,three&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27;,&#x27;</span> -f 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="-2"><a href="#-2" class="headerlink" title="# $ @"></a># $ @</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取数组的长度</span></span><br><span class="line">length=<span class="variable">$&#123;#array[@]&#125;</span></span><br></pre></td></tr></table></figure>

<p>@ 表示所有参数</p>
<p># 表示参数个数</p>
<p>${}负责提取结果</p>
<p>你一定还见过这些：</p>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<p>更完整的列表在<a href="https://tldp.org/LDP/abs/html/special-chars.html">这里</a> </p>
<h3 id="-3"><a href="#-3" class="headerlink" title="[] () [[]] (())"></a>[] () [[]] (())</h3><p>在 Bash 脚本中，<code>[]</code>、<code>[[]]</code>、<code>()</code> 和 <code>(())</code> 都是用于条件测试的，但它们之间有一些区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是 POSIX shell 的条件表达式。它支持文件和字符串测试，但不支持正则表达式或算术运算。</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> = <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is equal to b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是 Bash 的条件表达式。它提供了更多的功能，包括字符串比较、模式匹配、正则表达式和算术运算。</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> == <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is equal to b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是用于创建子 shell 的。在这个子 shell 中，你可以运行命令，而不会影响当前 shell 的环境。</span></span><br><span class="line">(a=hello; <span class="built_in">echo</span> <span class="variable">$a</span>)  <span class="comment"># prints &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>  <span class="comment"># prints nothing because the variable a is not defined in this shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是用于算术运算的。你可以在其中进行各种算术运算。</span></span><br><span class="line"><span class="keyword">if</span> ((a == b * <span class="number">2</span>))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;a is equal to b&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>



<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>它可以将标准输入数据<strong>转换为命令行参数</strong>，或者从文件的输出中读取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多行文本转换为单行文本</span></span><br><span class="line"><span class="built_in">cat</span> multiline.txt | xargs</span><br><span class="line"><span class="built_in">ls</span> | xargs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取输入，并将输入作为参数传递给其他命令, 比如找到所有的.log文件并删除</span></span><br><span class="line">find /path/to/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> | xargs <span class="built_in">rm</span> -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有的`.jpg`文件，并且将它们压缩</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.jpg&quot;</span> -<span class="built_in">print</span> | xargs tar -czvf images.tar.gz</span><br></pre></td></tr></table></figure>



<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按名称</span></span><br><span class="line">find . -name filename</span><br><span class="line"><span class="comment"># 按类型 比如目录</span></span><br><span class="line">find . -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 按大小 比如大于1M的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size +1M</span><br><span class="line"><span class="comment"># 按权限</span></span><br><span class="line">find . -<span class="built_in">type</span> f -perm 777</span><br><span class="line"><span class="comment"># 按修改时间</span></span><br><span class="line">find . -<span class="built_in">type</span> f -mtime -7</span><br><span class="line"><span class="comment"># 对找到的文件执行操作，比如删除找到的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.tmp&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"><span class="comment"># 更高级的操作 查看最近使用的文件</span></span><br><span class="line"><span class="comment"># 下方xargs使用了-0，表示将收到的参数用空字符隔开，而不是空格，用于区别包含空格的文件名</span></span><br><span class="line">find . -<span class="built_in">type</span> f -mmin -60 -print0 | xargs -0 <span class="built_in">ls</span> -lt | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure>



<h2 id="a-b-c"><a href="#a-b-c" class="headerlink" title="{a,b,c}"></a>{a,b,c}</h2><p>{}会将这里面的内容展开，有以下的妙用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这将创造三个txt</span></span><br><span class="line"><span class="built_in">touch</span> &#123;a,b,c&#125;.txt</span><br><span class="line"><span class="comment"># 你还可以这样做：</span></span><br><span class="line"><span class="built_in">touch</span> &#123;a,b,c&#125;_&#123;d,e&#125;.txt</span><br><span class="line"><span class="built_in">ls</span> </span><br><span class="line">a_d.txt  a_e.txt  b_d.txt  b_e.txt  c_d.txt  c_e.txt</span><br><span class="line"><span class="comment"># 还可以这样: </span></span><br><span class="line"><span class="built_in">touch</span> &#123;1..10&#125;.txt <span class="comment"># 展开[1,10]区间所有的整数，并创建对应名称的txt</span></span><br></pre></td></tr></table></figure>



<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>linux操作</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发-JNI</title>
    <url>/2024/09/07/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91-JNI/</url>
    <content><![CDATA[<p>Java Native Interface</p>
<span id="more"></span>
<h2 id="环境配置-linux"><a href="#环境配置-linux" class="headerlink" title="环境配置-linux"></a>环境配置-linux</h2><p>需要配置java，ndk，gcc，在linux上配置这些相对简单，直接apt install即可。</p>
<h2 id="JNI编程"><a href="#JNI编程" class="headerlink" title="JNI编程"></a>JNI编程</h2><p>项目代码建议放在linux下，windows编译的产物和中间件产物有冲突，本文介绍的也是使用linux编译，后续涉及的所有命令行操作都推荐在linux上执行。</p>
<p>一般我们对JNI进行如下分层：</p>
<p>Java应用层: Java代码部分，包括调用JNI方法的业务逻辑。<br>JNI接口层: Java与本地代码交互的接口，这一层包括Java中的声明和调用native方法。<br>JNI库层: 提供JNI函数和数据类型的库，实现了JNI接口的底层实现。<br>本地代码层: 通常是用C或C++编写的代码，它们实现了实际的业务功能。<br>Java虚拟机（JVM）层: JVM管理Java程序的执行。<br>JNI接口层  将需要和C++对接的函数声明为native  </p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p><strong>使用System.loadLibrary加载native库</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Jni.java: </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jni</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> num)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">addVec</span><span class="params">(<span class="type">int</span> idx, MyVec vec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;myvec&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JNI库层</strong></p>
<p>将JNI接口层的.java文件导出为.h文件</p>
<p>javac -h .&#x2F; -cp .&#x2F;java .&#x2F;java&#x2F;com&#x2F;example&#x2F;projectName&#x2F;jni&#x2F;Jni.java   </p>
<p>选项说明：</p>
<p>-h    指定头文件生成目录为当前目录<br>-cp  指定类路径(classpath)为.&#x2F;java目录<br>最后指定类文件为Jni.java</p>
<p>将得到的.h文件放到jni目录下，jni目录一般和app平级，一般我们会得到类似这样的函数声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class: com_example_projectName_jni_Jni</span></span><br><span class="line"><span class="comment">* Method: isEmpty</span></span><br><span class="line"><span class="comment">* Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_example_projectName_jni_Jni_isEmpty</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class: com_example_projectName_jni_Jni</span></span><br><span class="line"><span class="comment">* Method: add</span></span><br><span class="line"><span class="comment">* Signature: (II)Z</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">JNIEXPORT jboolean JNICALL <span class="title">Java_com_example_projectName_jni_Jni_add</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv *, jobject, jint, jint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class: com_example_projectName_jni_Jni</span></span><br><span class="line"><span class="comment">* Method: addVec</span></span><br><span class="line"><span class="comment">* Signature: (ILcom/example/projectName/utils/MyVec;)Z</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">JNIEXPORT jboolean JNICALL <span class="title">Java_com_example_projectName_jni_Jni_addVec</span></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv *, jobject, jint, jint, jobject, jobject)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下一步将.h复制一份，改为.c，后续我们就修改.c的内容。</p>
<h3 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>本地类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
<td>C&#x2F;C++ 8位整型</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>C&#x2F;C++ 带符号的8位整型</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>C&#x2F;C++ 无符号的16位整型</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>C&#x2F;C++ 带符号的16位整型</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>C&#x2F;C++ 带符号的32位整型</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>C&#x2F;C++ 带符号的64位整型</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>C&#x2F;C++ 32位浮点型</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>C&#x2F;C++ 64位浮点型</td>
</tr>
<tr>
<td>Object</td>
<td>jobject</td>
<td>任何Java对象，或者没有对应Java类型的对象</td>
</tr>
<tr>
<td>Class</td>
<td>jclass</td>
<td>Class对象</td>
</tr>
<tr>
<td>String</td>
<td>jstring</td>
<td>字符串对象</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>任何对象的数组</td>
</tr>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>布尔型数组</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>比特型数组</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>字符型数组</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>短整型数组</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>整型数组</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>长整型数组</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>浮点型数组</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>双浮点型数组</td>
</tr>
</tbody></table>
<p>注意Boolean是Object，在java应用中我们经常将Integer或Boolean直接当作基本数据类型使用，但是在JNI项目中必须严格区分它们。</p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>分为两种类型，第一种从java传到JNI的传入参数，第二种将参数return或者回传</p>
<p><strong>传入参数</strong></p>
<p>基本数据类型比如int→jint能直接传递，但是引用类型Integer必须用jobject接收，经过解析后才能得到对应的值，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jboolean JNICALL <span class="title function_">Java_com_example_projectName_jni_Jni_addVec</span><span class="params">(JNIEnv *env, jobject thiz, jint idx, jobject vec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开发中</span></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回传参数和return值</strong></p>
<p>上文中，直接返回了基本数据类型jboolean，对应java的boolean（注意不是Boolean），一般返回值都使用布尔值而不是引用类型，而如果需要返回多个参数的情况下，可以返回自定义类型或者使用参数回传的方式</p>
<p>参数回传只能使用引用类型（基本数据类型使用指针类型可以回传），如下，演示如何返回引用类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jboolean JNICALL <span class="title function_">Java_com_example_projectName_jni_Jni_addVec</span><span class="params">(JNIEnv *env, jobject thiz, jint idx, jobject vec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开发中</span></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再给一个修改数组并回传的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jboolean JNICALL <span class="title function_">Java_com_example_projectName_jni_Jni_addVec</span><span class="params">(JNIEnv *env, jobject thiz, jint idx, jobject vec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开发中</span></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个释放操作有点意思，函数原型：</p>
<p>void ReleaseIntArrayElements(JNIEnv *env, jintArray array, jint *elems, jint mode);</p>
<p>env: JNI 环境指针，用于调用 JNI 函数。</p>
<p>array: 要释放的 Java 数组。</p>
<p>elems: 之前通过 GetIntArrayElements 获取的本地数组指针。</p>
<p>mode: 释放模式，这个参数有以下几种取值：</p>
<p>0: 复制回 Java 数组并释放本地数组。<br>JNI_COMMIT: 复制回 Java 数组但不释放本地数组（数组仍然可供本地代码访问）。<br>JNI_ABORT: 不复制回 Java 数组，只释放本地数组。</p>
<h2 id="打包JNI"><a href="#打包JNI" class="headerlink" title="打包JNI"></a>打包JNI</h2><p>在上一章我们得到了Jni.java，以及.c和.h文件，java代码将打包为jar包，作为JNI接口层给应用使用；而c代码将打包为.so，也就是上文的JNI库。</p>
<p>（一）打jar包</p>
<p>我有两个目录需要打包：jni&#x2F;Jni.java，Tutils&#x2F;.*java，打包过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">javac -parameters -d classes jni/Jni.java utils<span class="comment">/*.java</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">jar cf Jni.jar -C classes/ .</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>-parameters 保留函数参数名</p>
<p>-d 指定生成目录</p>
<p>cf 创建新文件并指定文件名</p>
<p>-C classes&#x2F; . 将classes目录中的所有文件打包</p>
<p>（二)  编译JNI库</p>
<p>jni库结构如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">project\jni\include\xxx.h</span><br><span class="line"></span><br><span class="line">project\jni\libs\armeabi-v7a\libxxx.so</span><br><span class="line"></span><br><span class="line">project\jni\Android.mk</span><br><span class="line"></span><br><span class="line">project\jni\Application.mk</span><br><span class="line"></span><br><span class="line">project\jni\projectName_jni.c</span><br><span class="line"></span><br><span class="line">project\jni\projectName_jni.h</span><br></pre></td></tr></table></figure>



<p>推荐在linux上使用ndk-build编译，需要编写两个mk文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//==========Application.mk</span><br><span class="line"></span><br><span class="line">APP_ABI := armeabi-v7a </span><br><span class="line">APP_PLATFORM := android-29</span><br><span class="line">NDK_TOOLCHAIN_VERSION := clang</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//=========Anroid.mk</span><br><span class="line"></span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line"># 定义头文件搜索路径和动态库搜索路径</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)  </span><br><span class="line">LOCAL_MODULE := libadd</span><br><span class="line">LOCAL_SRC_FILES := libs/$(TARGET_ARCH_ABI)/libadd.so      </span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include  </span><br><span class="line">LOCAL_EXPORT_C_INCLUDES += $(LOCAL_PATH)/include</span><br><span class="line">include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line"></span><br><span class="line">...&lt;重复上一段，可定义多个库&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS      = -CFLAGS ...  # 编译选项</span><br><span class="line">LOCAL_LDLIBS      += -llog           #系统动态库</span><br><span class="line">LOCAL_MODULE     := projectName      # 目标产物名称</span><br><span class="line"></span><br><span class="line">#其它头文件搜索路径</span><br><span class="line"></span><br><span class="line">LOCAL_C_INCLUDES := $(LOCAL_PATH)       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 源文件路径</span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">          projectName_jni.c \ </span><br><span class="line"></span><br><span class="line"># 链接上方声明的动态库，比如我需要链接libadd.so</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES := libadd </span><br><span class="line"></span><br><span class="line">#编译成动态库</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在jni目录下: ndk-build</p>
<p>生成的产物默认出现在jni同级的libs目录中，一般类似libs&#x2F;armeabi-v7a&#x2F;libxxx.so的形式。</p>
<h2 id="使用JNI"><a href="#使用JNI" class="headerlink" title="使用JNI"></a>使用JNI</h2><p>上一章中，得到了一个jar包和一个.so</p>
<p>将jar包放到app下的libs中，有必要的话右键该jar包并add as library</p>
<p>将.so放到app平级的Jnilibs中（如果没有的就新建），或者通过修改build.gradle的相关配置，比如设置为app下的libs:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main&#123;</span><br><span class="line">        main.jni.srcDirs = []</span><br><span class="line">        main.jniLibs.srcDirs = [<span class="string">&#x27;libs&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编快速入门</title>
    <url>/2024/10/07/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>首先看懂汇编</p>
<span id="more"></span>
<p>之前玩过图灵完备，实现了一些简单的寄存器、CPU、栈。能够进行函数的call和ret等基础操作，所以理解的快一些，这篇文章目前不打算介绍概念，直接上代码。<br>本文使用MASM编程。</p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>首先下载好MASM相关包，并将其放在根目录（方便），如下： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> D:\MASM 的目录</span><br><span class="line"></span><br><span class="line">20/10/2024  上午11:45    &lt;DIR&gt;          .</span><br><span class="line">10/01/2000  下午08:00            20,634 DEBUG.EXE</span><br><span class="line">10/01/2000  下午08:00            69,886 edit.com</span><br><span class="line">04/04/1996  下午01:30            30,776 EDIT.EXE</span><br><span class="line">08/03/1983  下午12:00             4,608 EDLIN.COM</span><br><span class="line">21/05/1992  上午10:22            64,992 LINK.EXE</span><br><span class="line">21/05/1992  上午10:21           103,184 MASM.EXE</span><br><span class="line">               7 个文件        294,358 字节</span><br><span class="line">               1 个目录 46,358,425,600 可用字节</span><br></pre></td></tr></table></figure>

<p>打开MASM，输入指令:<br><code>mount c d:masm</code> 将masm目录挂载，并用符号c表示<br><code>c:</code> 进入masm工作目录<br><code>debug</code> 打开debug工具  </p>
<p>在 MASM 的 <code>debug</code> 工具中，这些指令的英文缩写通常代表以下含义：</p>
<ol>
<li><p>R：Registers，查看或修改寄存器内容。</p>
</li>
<li><p>D：Dump，查看内存内容。</p>
</li>
<li><p>E：Enter data，改写内存内容。</p>
</li>
<li><p>U：Unassemble，查看内存内容对应的汇编指令。</p>
</li>
<li><p>T：Trace，执行指令。</p>
</li>
<li><p>A：Assemble，改写内存内容（从指令角度）。</p>
</li>
</ol>
<img src="/2024/10/07/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/ZN-CH.png" class="" title="汇编快速入门">

<p><strong>寄存器位数:</strong><br>上图中首先可以看到abcd四个寄存器，文字说明如下：<br>ax: 16位<br>al: 低8位<br>ah: 高8位</p>
<p><strong>四则运算</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add ax,bx  </span><br><span class="line">sub ax,bx  </span><br><span class="line">mul bl:    al * bl = ax;   ax * bx = dxax;  </span><br><span class="line">div bl:    ax / bl = al ... ah;  dxax / bx = ax ... dx;  </span><br></pre></td></tr></table></figure>
<p>加法与乘法低位之间运算溢出后在高位进位，高位的运算溢出后，在dx中补<br>减法与除法也是类似的，低位运算靠ah存余数，高位运算用dx存数  </p>
<p><strong>基本指令</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xchg ax,bx    交换寄存器内容</span><br><span class="line">neg ax        符号取反</span><br><span class="line">mov ax,[<span class="number">60</span>]   将ds数据段中偏移为<span class="number">60</span>的数据放在ax</span><br><span class="line">mov ds,<span class="number">1234</span>   这样是不允许的，但是mov ds,ax是允许的</span><br><span class="line">jmp <span class="number">1000</span>:<span class="number">3</span>    跳转指令</span><br><span class="line">and al, <span class="number">1</span>H    与操作</span><br><span class="line">or  al, <span class="number">0110b</span> 或操作</span><br></pre></td></tr></table></figure>
<p>s结尾的称为段寄存器，不可以用立即数给它赋值</p>
<p><strong>堆栈操作</strong><br>在linux虚拟内存分区中，栈是从高地址往低地址生长的：</p>
<img src="/2024/10/07/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" class="" title="汇编快速入门">

<p>SS:SP 指向栈顶<br>BX 基址寄存器，[bx] 指向DS:bx<br>BP 基址寄存器，[bp] 指向SS:BP  </p>
<p><strong>标志位</strong>  </p>
<ol>
<li>OF over 溢出 标志位<ul>
<li>OV overflow</li>
<li>NV not overflow</li>
</ul>
</li>
<li>DF direction 方向 标志位<ul>
<li>DN down 减</li>
<li>UP up</li>
</ul>
</li>
<li>IF interrupt 允许中断 标志位<ul>
<li>EI enable允许</li>
<li>DI disable</li>
</ul>
</li>
<li>SF sign 符号 标志位<ul>
<li>NG  NeGative 负数</li>
<li>PL  Plus</li>
</ul>
</li>
<li>ZF zero 零 标志位<ul>
<li>ZR :zero</li>
<li>NZ :not zero</li>
</ul>
</li>
<li>AF auxiliary 辅助进位 标志位<ul>
<li>AC assistant carry 进位</li>
<li>NA no assistant carry 无进位</li>
</ul>
</li>
<li>PF parity 奇偶标志位 <ul>
<li>PE: even</li>
<li>PO: odd</li>
</ul>
</li>
<li>CF carry 进位标志位<ul>
<li>CY  carry yes</li>
<li>NC  no carry</li>
<li>adc 加法, 同时加上CF的值  </li>
<li>sbb 减法, 同时减去CF的值</li>
</ul>
</li>
<li>TF Trap 追踪 标志位<ul>
<li>当TF为1时，CPU进入单步调试模式，每执行一次指令，产生一次中断请求</li>
</ul>
</li>
</ol>
<p><strong>条件跳转</strong><br>cmp 相当于不保存结果的减法，通过查看标志位得到cmp结果  </p>
<blockquote>
<p>je 等于跳转      zf &#x3D; 1<br>jne 不等于跳转   zf &#x3D; 0<br>jb below 小于   cf &#x3D; 1<br>jnb  不小于     cf &#x3D; 0<br>ja above 大于   cf &#x3D; 0 &amp;&amp; zf &#x3D; 0<br>jna 不大于      cf &#x3D; 1 &amp;&amp; zf &#x3D; 1  </p>
</blockquote>
<p>比如：如果ax&gt;&#x3D;bx则跳转：<br>cmp ax,bx<br>jnb 012F:0100  </p>
<p><strong>直接跳转</strong><br>jmp short s  段内跳转<br>jmp far ptr s  远距离跳转  </p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码放在MASM.EXE同级目录下  </p>
<p>编写源文件code.asm  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    &lt;code&gt;</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>打注释方式</strong>  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">;这是注释1</span><br><span class="line"></span><br><span class="line">comment*</span><br><span class="line">    这是注释2</span><br><span class="line">*comment</span><br></pre></td></tr></table></figure>


<p><strong>终端命令:</strong><br>#生成code.obj<br>&gt; masm<br>&gt; code  </p>
<p>链接，生成code.exe<br>&gt;link<br>&gt;code.obj  </p>
<p>以debug方式运行：<br>&gt;debug code.exe</p>
<p><strong>数据定义</strong><br>db： define byte<br>dw： define word<br>dd： define double word<br>dq： define q… word  </p>
<p>db 10 dup (123)： 定义10个123<br>db 3 dup (1,2,3)：1 2 3 1 2 3 1 2 3</p>
<p><strong>数据代码分区存储：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">assume cs:codesg,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">  db <span class="string">&quot;hello world&#x27;</span></span><br><span class="line"><span class="string">  db 3 dup (1,2,3)</span></span><br><span class="line"><span class="string">data ends</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">stack segment</span></span><br><span class="line"><span class="string">  db 10 dup (0)</span></span><br><span class="line"><span class="string">stack ends</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">codesg segment</span></span><br><span class="line"><span class="string">start:</span></span><br><span class="line"><span class="string">  mov ax, 3</span></span><br><span class="line"><span class="string">  mov cx,11</span></span><br><span class="line"><span class="string">  call func</span></span><br><span class="line"><span class="string">  inc bx</span></span><br><span class="line"><span class="string">  int 21H</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func:</span></span><br><span class="line"><span class="string">  add ax,ax</span></span><br><span class="line"><span class="string">  loop func</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">codesg ends</span></span><br><span class="line"><span class="string">end start</span></span><br></pre></td></tr></table></figure>

<p>offset 获取label所在的位置，比如上述代码中，添加这一行：<br><code>mov ax,offset func</code><br>表示将func的地址赋值给ax  </p>
<p><strong>数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr db <span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>  定义一个数据数组  </span><br><span class="line">mov ax, word ptr arr[<span class="number">2</span>] 将数组<span class="number">2</span>号地址赋值给ax  </span><br><span class="line">mov word ptr ds:[<span class="number">2</span>],<span class="number">0</span> 将<span class="number">0</span>赋值给内存的<span class="number">2</span>号地址  </span><br><span class="line">jmp word ptr ds:[<span class="number">0</span>] 读取内存中的第一个数作为跳转目标，修改ip  </span><br><span class="line">jmp dword ptr ds:[<span class="number">0</span>] 读取内存中的第一个数作为跳转目标, 修改cs:ip  </span><br></pre></td></tr></table></figure>

<h2 id="练手demo"><a href="#练手demo" class="headerlink" title="练手demo"></a>练手demo</h2><h3 id="输出helloworld"><a href="#输出helloworld" class="headerlink" title="输出helloworld"></a>输出helloworld</h3><p><strong>1. 直接输出</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:<span class="built_in">stack</span></span><br><span class="line">data segment</span><br><span class="line">; <span class="number">10</span>没有打引号，是一个控制字符<span class="string">&quot;回车&quot;</span>,`$`表示终止输出</span><br><span class="line">  str db <span class="string">&quot;Hello world&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;Hi$&#x27;</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> segment</span><br><span class="line">  db <span class="number">10</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="built_in">stack</span> ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">  mov ax, data</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov dx, offset str</span><br><span class="line">  mov ah, <span class="number">9</span>H        ; 输出指令，读取数据段并输出</span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H          ; 中断，识别并执行ax中的指令</span><br><span class="line">  </span><br><span class="line">    mov dl, <span class="string">&#x27;$&#x27;</span>      ; 上面到终止符就终止了，要输出<span class="string">&#x27;$&#x27;</span>符号需要单独输出</span><br><span class="line">    mov ah, <span class="number">02</span>h      ; 输出单个字符，该指令只关心dl的值</span><br><span class="line">    <span class="type">int</span> <span class="number">21</span>h          ; 中断，单独输出 <span class="string">&#x27;$&#x27;</span> 符号</span><br><span class="line"></span><br><span class="line">  mov ah, <span class="number">4</span>cH       ; 程序退出指令</span><br><span class="line">    mov al, <span class="number">0</span>H       ; 退出代码为<span class="number">0</span></span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H          ; 中断，并执行退出指令</span><br><span class="line">   </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>2.大小写转换输出</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a: <span class="number">97</span>  <span class="number">61</span>H  <span class="number">0110</span> <span class="number">0001</span>  </span><br><span class="line">z: <span class="number">122</span> <span class="number">7</span>AH  <span class="number">0111</span> <span class="number">1010</span>  </span><br><span class="line">A: <span class="number">65</span>  <span class="number">41</span>H  <span class="number">0100</span> <span class="number">0001</span>  </span><br><span class="line">Z: <span class="number">90</span>  <span class="number">5</span>A   <span class="number">0101</span> <span class="number">1010</span>  </span><br></pre></td></tr></table></figure>
<p>可以发现一个有趣的现象：  </p>
<ul>
<li>a&#x2F;A都是从0001开始，1010结束  </li>
<li>小写高位第2位一定是1，大写高位第2位一定是0</li>
</ul>
<p>那么转大写就只要<code>&amp; 1101 1111</code>,转小写就只要<code>| 0010 0000</code>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:<span class="built_in">stack</span></span><br><span class="line">data segment</span><br><span class="line">  str db <span class="string">&quot;HeLLo WorlD$&quot;</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> segment</span><br><span class="line">  db <span class="number">10</span> dup (<span class="number">1</span>)</span><br><span class="line"><span class="built_in">stack</span> ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">  mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">  lea dx, str             ; 等价于 mov dx, offset str    </span><br><span class="line">  </span><br><span class="line">  mov bx, <span class="number">0</span>               ; 基址寄存器</span><br><span class="line">  mov cx, <span class="number">11</span>              ; 计数寄存器</span><br><span class="line">  </span><br><span class="line">  func:</span><br><span class="line">    mov al, str[bx]     ; 将str中的数据按位传给al</span><br><span class="line">    and al, <span class="number">0</span>DFH        ; 转大写，这里单独写DFH，编辑器识别不到这是个立即数，需要前面加个<span class="number">0</span>，也可以写成<span class="number">11011111b</span>, 或者对应的<span class="number">10</span>进制</span><br><span class="line">    ; or al, <span class="number">20</span>H        ; 转小写</span><br><span class="line">    mov str[bx], al     ; 数据写回</span><br><span class="line">    inc bx              ; 基址自增</span><br><span class="line">    loop func           ; 循环，该指令会读取cx做条件判断，并令cx --</span><br><span class="line"></span><br><span class="line">  mov ah, <span class="number">9</span>H</span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">  </span><br><span class="line">  mov ah, <span class="number">4</span>cH  </span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>有一点需要注意，<code>mov al, str[bx]</code>中 <code>str[bx]</code>实际上的地址是<code>ds:str+bx</code>同时也等价于<code>mov al, [bx]</code>，这个写法实际地址是<code>ds:dx+bx</code>,由此可见，不管是何种方式，都需要提前设置好<code>ds</code>，不然会出问题</p>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p><strong>1.求斐波拉契数列</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:<span class="built_in">stack</span></span><br><span class="line">data segment</span><br><span class="line">    arr db <span class="number">20</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> segment</span><br><span class="line">  db <span class="number">10</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="built_in">stack</span> ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">  mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    </span><br><span class="line">    mov ax, <span class="number">1</span></span><br><span class="line">    mov arr[<span class="number">0</span>], al</span><br><span class="line">    mov arr[<span class="number">1</span>], al</span><br><span class="line"></span><br><span class="line">    mov bx, <span class="number">2</span></span><br><span class="line">    mov si, <span class="number">0</span></span><br><span class="line">    mov di, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mov cx, <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span>:</span><br><span class="line">        mov al, arr[si]</span><br><span class="line">        add al, arr[di]</span><br><span class="line">        mov arr[bx], al</span><br><span class="line"></span><br><span class="line">        mov si, di</span><br><span class="line">        mov di, bx</span><br><span class="line">        inc bx</span><br><span class="line">        loop <span class="keyword">for</span></span><br><span class="line"></span><br><span class="line">; 此时如果直接输出数据，发现会乱码，如何输出结果，将在下一节字符串处理介绍</span><br><span class="line">    mov cx, <span class="number">10</span></span><br><span class="line">    mov dx, <span class="number">0</span></span><br><span class="line">    print:</span><br><span class="line">        mov ax, <span class="number">0200</span>H</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">        inc dx</span><br><span class="line">        loop print</span><br><span class="line"></span><br><span class="line">  mov ah, <span class="number">4</span>cH  </span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>使用debug指令查看数据段内存，可以看到：<br>01 01 02 03 05 08 0D 15 22 37  </p>
<p><strong>2.二维数组</strong><br>回想一下C语言的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vec[<span class="number">10</span>];        申请了<span class="number">10</span>个<span class="type">int</span>的空间</span><br><span class="line">vec[<span class="number">2</span>] 等价于 *(vec + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">升级看看：</span><br><span class="line"><span class="type">int</span> vec[<span class="number">10</span>][<span class="number">10</span>];    <span class="comment">// 申请了10*10*sizeof(int)的空间</span></span><br><span class="line">vec[<span class="number">2</span>][<span class="number">3</span>] 等价于 (*(vec + <span class="number">2</span>))[<span class="number">3</span>] 等价于 *((*(vec + <span class="number">2</span>)) + <span class="number">3</span>) 等价于 *(&amp;vec[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">2</span> * <span class="number">10</span> + <span class="number">3</span>) </span><br><span class="line">可见二维数组其实等于一堆头尾相连的一维数组</span><br></pre></td></tr></table></figure>
<p>题外话:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vec[<span class="number">0</span>][<span class="number">0</span>] == **(vec + <span class="number">0</span>)</span><br><span class="line">vec[<span class="number">2</span>][<span class="number">3</span>] == *(&amp;vec[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">2</span> * <span class="number">10</span> + <span class="number">3</span>) </span><br><span class="line">那么vec[<span class="number">2</span>][<span class="number">3</span>]能否等于**(vec + <span class="number">23</span>)呢？</span><br><span class="line">答案是不可以，vec + <span class="number">23</span> 在转成汇编后，实际得到的是vec + <span class="number">23</span> * <span class="number">10</span>，也就是vec + <span class="number">23</span> * &lt;一维数组大小&gt;</span><br></pre></td></tr></table></figure>
<p>那么我们实现二维数组的思路也就有了，做下转换即可，上点难度，试着计算杨辉三角吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为在内存中是连续存储的，最终效果是：<br><code>01 01 01 01 02 01 01 03 03 01 01 04 06 04 01 01</code><br><code>05 0A 0A 05 01</code><br>代码如下：（如果编写C语言版并反汇编的话，会发现和我写的完全不一样，因为我只会用寄存器存值，这里还没把栈搞明白）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:<span class="built_in">stack</span></span><br><span class="line">data segment</span><br><span class="line">    arr db <span class="number">50</span> dup(<span class="number">0</span>)</span><br><span class="line">    gi dw <span class="number">1</span> dup(<span class="number">0</span>)</span><br><span class="line">    gj dw <span class="number">1</span> dup(<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> segment</span><br><span class="line">  db <span class="number">100</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="built_in">stack</span> ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">  mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    </span><br><span class="line">    mov ax, <span class="number">1</span></span><br><span class="line">    mov arr[<span class="number">0</span>], al</span><br><span class="line"></span><br><span class="line">    mov gi, ax</span><br><span class="line">    fori:</span><br><span class="line">        mov ax, <span class="number">0</span></span><br><span class="line">        mov gj, ax</span><br><span class="line">        forj:</span><br><span class="line">        ; bx = ((<span class="number">1</span> + i) * i) / <span class="number">2</span> + j</span><br><span class="line">            mov ax, gi</span><br><span class="line">            add ax, <span class="number">1</span></span><br><span class="line">            mul gi</span><br><span class="line">            mov bx, <span class="number">2</span></span><br><span class="line">            div bx</span><br><span class="line">            add ax, gj</span><br><span class="line">            mov bx, ax </span><br><span class="line">        ; <span class="keyword">if</span> j != i</span><br><span class="line">            mov si, gi</span><br><span class="line">            mov di, gj</span><br><span class="line">            cmp si, di</span><br><span class="line">            je label1</span><br><span class="line">        ; f[bx] = f[bx - i]</span><br><span class="line">            mov si, bx</span><br><span class="line">            sub si, gi</span><br><span class="line">            mov al, [si]</span><br><span class="line">            mov [bx], al</span><br><span class="line">        label1:</span><br><span class="line">        ; <span class="keyword">if</span> j != <span class="number">0</span></span><br><span class="line">            cmp gj, <span class="number">0</span></span><br><span class="line">            je label2</span><br><span class="line">        ; f[bx] += f[bx - i - <span class="number">1</span>];</span><br><span class="line">            mov ax, bx</span><br><span class="line">            mov si, gi</span><br><span class="line">            sub ax, si</span><br><span class="line">            sub ax, <span class="number">1</span></span><br><span class="line">            mov si, ax</span><br><span class="line">            mov cl, arr[si]</span><br><span class="line">            add arr[bx], cl</span><br><span class="line">        label2:</span><br><span class="line">            mov si, gi</span><br><span class="line">            inc gj</span><br><span class="line">            mov di, gj</span><br><span class="line">            cmp si, di</span><br><span class="line">        jnb forj</span><br><span class="line">        </span><br><span class="line">        inc gi</span><br><span class="line">        cmp gi, <span class="number">6</span></span><br><span class="line">    jb fori</span><br><span class="line">    </span><br><span class="line">  mov ax, <span class="number">4</span>c00H  </span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>3.冒泡排序</strong><br>冒泡是非常简单的排序，而且可以直接在原数组上操作，汇编实现不难，这里就当是给读者留的作业</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>字符串处理在汇编中其实是对数组的处理</p>
<p><strong>1.数字转换</strong><br>字符串-数字互转，这个需求很常见，但在汇编里往往很麻烦，如下演示将十进制数的字符串，转为计算机能识别的数字，再打印出16进制形式</p>
<p>伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.length(); i ++) &#123;</span><br><span class="line">    <span class="type">int</span> x = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    ans = ans * <span class="number">10</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一章没有用过函数，也没有实现直接栈内的局部变量，这次我们来一次满足  </p>
<p>需求: 编写一个转换函数，参数是字符串的首地址和长度，返回值是转换后的值。在data中定义三组数字（字符串），循环将三组数据用转换函数处理后并输出结果。</p>
<p>码代码ing…</p>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><p>正编  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">预处理 展开各种代码</span><br><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">编译 生成汇编文件</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">汇编 生成二进制文件</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">连接 生成可执行文件</span><br><span class="line">gcc hello.o -o hello</span><br><span class="line">一步到胃</span><br><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<p>反编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c -o hello  <span class="comment">// 要在汇编显示对应源码，就要用-g选项</span></span><br><span class="line">objdump -S hello &gt; hello.obj</span><br></pre></td></tr></table></figure>



<div id="gitalk-container"></div>
<script>
const gitalk = new Gitalk({
  clientID: 'Ov23ctteY5rA6HskBCFV',
  clientSecret: '2b7f82ef23a3a69db4bf9f59d8ee02836ea2129f',
  repo: 'xuehuasu.github.io',      // The repository of store comments,
  owner: 'xuehuasu',
  admin: ['xuehuasu'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

<p>gitalk.render(‘gitalk-container’)<br></script></p>
]]></content>
      <categories>
        <category>汇编</category>
        <category>入门</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
